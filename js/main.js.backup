let devices = {}

async function onRequestBluetoothDeviceButtonClick() {
  try {
    const currentDevice = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true
    })
  } catch (error) {
    console.log('Argh! ' + error)
  }
  await onGetBluetoothDevicesButtonClick()
}

async function onGetBluetoothDevicesButtonClick() {
  try {
    const currentDevices = await navigator.bluetooth.getDevices()

    devices = {};
    for (const device of currentDevices) {
      devices[device.id] = {
        id: device.id,
        name: device.name,
        status: 'unknown'
      }
    }

    await updateTable()
  } catch (error) {
    console.log('Argh! ' + error)
  }
}

async function updateTable() {
  const tbodyEl = document.querySelector('#tbody-list-bt')
  tbodyEl.innerHTML = ''

  console.log(devices);
  let i = 1;
  Object.keys(devices).forEach(id => {
    const device = devices[id];

    const rowEl = document.createElement('tr')
    const slNoEl = document.createElement('td')
    const idEl = document.createElement('td')
    const nameEl = document.createElement('td')
    const statusEl = document.createElement('td')
    const statusBtnEl = document.createElement('button')
    statusBtnEl.innerHTML = device.status == 'connected' ? 'Disconnect' : device.status == 'disconnected' ? 'Connect' : 'Unknown'
    statusBtnEl.addEventListener('click', () => {
      onGetDeviceInfo(device.name)
    })

    slNoEl.innerHTML = (i++).toString()
    idEl.innerHTML = device.id
    nameEl.innerHTML = device.name
    statusEl.appendChild(statusBtnEl)


    rowEl.appendChild(slNoEl);
    rowEl.appendChild(idEl);
    rowEl.appendChild(nameEl);
    rowEl.appendChild(statusEl);

    tbodyEl.appendChild(rowEl);
  })
}

const pairBtn = document.querySelector('#btn-pair-bt')

pairBtn.addEventListener('click', onRequestBluetoothDeviceButtonClick)

const listBtn = document.querySelector('#btn-list-bt')

listBtn.addEventListener('click', onGetBluetoothDevicesButtonClick)

onGetBluetoothDevicesButtonClick()



async function onGetDeviceInfo(name) {
  const log = console.log
  try {
    log('Requesting any Bluetooth Device...');
    const device = await navigator.bluetooth.requestDevice({
      name,
      acceptAllDevices: true,
      optionalServices: ['device_information']
    });


    console.log(devices[device.id]);
    devices[device.id].status = device.gatt.connected ? 'connected' : 'disconnected';

    log('Connecting to GATT Server...');
    const server = await device.gatt.connect();

    log('Getting Device Information Service...');
    const service = await server.getPrimaryService('device_information');

    log('Getting Device Information Characteristics...');
    const characteristics = await service.getCharacteristics();

    const decoder = new TextDecoder('utf-8');
    for (const characteristic of characteristics) {
      switch (characteristic.uuid) {

        case BluetoothUUID.getCharacteristic('manufacturer_name_string'):
          await characteristic.readValue().then(value => {
            devices[device.id].manufacturer = decoder.decode(value);
          });
          break;

        case BluetoothUUID.getCharacteristic('model_number_string'):
          await characteristic.readValue().then(value => {
            devices[device.id].modelNumber = decoder.decode(value);
          });
          break;

        case BluetoothUUID.getCharacteristic('hardware_revision_string'):
          await characteristic.readValue().then(value => {
            devices[device.id].hardwareRevision = decoder.decode(value);
          });
          break;

        case BluetoothUUID.getCharacteristic('firmware_revision_string'):
          await characteristic.readValue().then(value => {
            devices[device.id].firmwareRevision = decoder.decode(value);
          });
          break;

        case BluetoothUUID.getCharacteristic('software_revision_string'):
          await characteristic.readValue().then(value => {
            devices[device.id].softwareRevision = decoder.decode(value);
          });
          break;

        case BluetoothUUID.getCharacteristic('system_id'):
          await characteristic.readValue().then(value => {
            devices[device.id].systemId = {
              manufacturerId:
              padHex(value.getUint8(4)) + padHex(value.getUint8(3)) +
                padHex(value.getUint8(2)) + padHex(value.getUint8(1)) +
                padHex(value.getUint8(0)),
                organizationallyUniqueId:
              padHex(value.getUint8(7)) + padHex(value.getUint8(6)) +
                padHex(value.getUint8(5))
            }
          });
          break;

        case BluetoothUUID.getCharacteristic('ieee_11073-20601_regulatory_certification_data_list'):
          await characteristic.readValue().then(value => {
            log('> IEEE 11073-20601 Regulatory Certification Data List: ' +
              decoder.decode(value));
          });
          break;
      }
    }
    await updateTable();
  } catch (error) {
    log('Argh! ' + error);
  }
}

/* Utils */

function padHex(value) {
  return ('00' + value.toString(16).toUpperCase()).slice(-2);
}

function getUsbVendorName(value) {
  // Check out page source to see what valueToUsbVendorName object is.
  return value +
    (value in valueToUsbVendorName ? ' (' + valueToUsbVendorName[value] + ')' : '');
}